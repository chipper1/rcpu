#!/usr/bin/env ruby
# encoding: utf-8

class Registers
  def initialize(mem)
    @mem = mem
    @reg = {
      0  => 0,      # r0
      1  => 0,      # r1
      2  => 0,      # r2
      3  => 0,      # r3
      4  => 0,      # r4
      5  => 0,      # r5
      6  => 0,      # r6
      7  => 0,      # r7
      8  => 0,      # rpc
      9  => 0,      # rflags
      10 => 0xffff, # rsp
      11 => 0,      # rbp
      12 => 0,      # rr
    }
  end

  def [](num)
    if num & 0x80 != 0x00
      address = self[num & ~0x80]
      (@mem.fetch(address + 0) << 24) +
      (@mem.fetch(address + 1) << 16) +
      (@mem.fetch(address + 2) << 8) +
      (@mem.fetch(address + 3) << 0)
    else
      @reg.fetch(num)
    end
  end

  def []=(num, value)
    if num & 0x80 != 0x00
      address = self[num & ~0x80]
      @mem[address + 0] = ((value & 0xff000000) >> 24)
      @mem[address + 1] = ((value & 0x00ff0000) >> 16)
      @mem[address + 2] = ((value & 0x0000ff00) >> 8)
      @mem[address + 3] = ((value & 0x000000ff))
    else
      @reg[num] = value
    end
  end

  def each
    @reg.each { |r| yield(r) }
  end
end

class Context
  attr_reader :reg
  attr_accessor :mem

  def initialize
    @mem = {}
    @reg = Registers.new(@mem)
  end

  def inspect
    stride = 10
    mem = ''
    i = 0
    prev_key = nil
    @mem.keys.sort.each do |key|
      # Split
      if prev_key && prev_key + 1 != key
        mem << "\n" << '----' << "\n"
        i = 0
      end
      prev_key = key

      mem << format('%04x=%02x ', key, @mem[key])

      mem << "\n" if i % stride == stride - 1
      i += 1
    end

    reg = ''
    reg << '┌─────┬───────────┬────────────┐' << "\n"
    reg << '│ loc │ val (hex) │ val (dec)  │' << "\n"
    reg << '├─────┼───────────┼────────────┤' << "\n"
    @reg.each do |loc, val|
      reg << '│ '
      reg << format('%3i', loc)
      reg << ' │ '
      reg << format(' %8x', val)
      reg << ' │ '
      reg << format('%10i', val)
      reg << ' │' << "\n"
    end
    reg << '└─────┴───────────┴────────────┘' << "\n"
    reg

    mem + "\n" + reg
  end
end

class CPU
  class HaltException < StandardError
  end

  def initialize(context)
    @context = context
  end

  def run
    loop do
      begin
        step
      rescue HaltException
        break
      end
    end
  end

  private

  def mem
    @context.mem
  end

  def reg
    @context.reg
  end

  PC = 8
  FLAGS = 9
  SP = 10
  BP = 11

  def step
    opcode = at_pc
    a0 = at_pc(1)
    a1 = at_pc(2)
    a2 = at_pc(3)
    a3 = at_pc(4)
    a4 = at_pc(5)
    a5 = at_pc(6)

    # puts @context.inspect
    # puts "*** 0x#{opcode.to_s(16)}"

    case opcode
    when 0x00 # nop
      advance(1)
    when 0x01 # call
      reg[SP] -= 4
      new_pc = reg[PC] + 5
      mem[reg[SP] + 0] = ((new_pc & 0xff000000) >> 24)
      mem[reg[SP] + 1] = ((new_pc & 0x00ff0000) >> 16)
      mem[reg[SP] + 2] = ((new_pc & 0x0000ff00) >> 8)
      mem[reg[SP] + 3] = ((new_pc & 0x000000ff))
      i = reconstruct_int(a0, a1, a2, a3)
      reg[PC] = i
    when 0x02 # ret
      i = reconstruct_int(
        mem.fetch(reg[SP] + 0),
        mem.fetch(reg[SP] + 1),
        mem.fetch(reg[SP] + 2),
        mem.fetch(reg[SP] + 3)
      )
      reg[SP] += 4
      reg[PC] = i
    when 0x03 # push
      raw = reg[a0]
      reg[SP] -= 4
      mem[reg[SP] + 0] = ((raw & 0xff000000) >> 24)
      mem[reg[SP] + 1] = ((raw & 0x00ff0000) >> 16)
      mem[reg[SP] + 2] = ((raw & 0x0000ff00) >> 8)
      mem[reg[SP] + 3] = ((raw & 0x000000ff))
      advance(2)
    when 0x04 # pushi
      reg[SP] -= 4
      mem[reg[SP] + 0] = a0
      mem[reg[SP] + 1] = a1
      mem[reg[SP] + 2] = a2
      mem[reg[SP] + 3] = a3
      advance(5)
    when 0x05 # pop
      reg[a0] = reconstruct_int(
        mem.fetch(reg[SP] + 0),
        mem.fetch(reg[SP] + 1),
        mem.fetch(reg[SP] + 2),
        mem.fetch(reg[SP] + 3)
      )
      reg[SP] += 4
      advance(2)
    when 0x06 # jmpi
      i = reconstruct_int(a0, a1, a2, a3)
      reg[PC] = i
    when 0xa6 # jmp
      reg[PC] = reg[a0]
    when 0x07 # je
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x01 == 0x01 then reg[PC] = i else advance(5) end
    when 0x08 # jne
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x01 == 0x00 then reg[PC] = i else advance(5) end
    when 0x09 # jg
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x02 == 0x02 then reg[PC] = i else advance(5) end
    when 0x0a # jge
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x03 != 0x00 then reg[PC] = i else advance(5) end
    when 0x0b # jl
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x03 == 0x00 then reg[PC] = i else advance(5) end
    when 0x0c # jle
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x02 == 0x00 then reg[PC] = i else advance(5) end
    when 0x0d # not
    when 0x0e # prn
      puts "#{reg[a0]}"
      advance(2)
    when 0x0f # mov
      reg[a0] = reg[a1]
      advance(3)
    when 0x10 # movi
      reg[a0] = reconstruct_int(a1, a2, a3, a4)
      advance(6)
    when 0x11 # cmp
      reg[FLAGS] =
        (reg[a0] == reg[a1] ? 0x01 : 0x00) |
        (reg[a0] > reg[a1]  ? 0x02 : 0x00)
      advance(3)
    when 0x12 # cmpi
      i = reconstruct_int(a1, a2, a3, a4)
      reg[FLAGS] =
        (reg[a0] == i ? 0x01 : 0x00) |
        (reg[a0] > i  ? 0x02 : 0x00)
      advance(6)
    when 0x13 # mod
      reg[a0] = reg[a1] % reg[a2]
      advance(4)
    when 0x14 # modi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = reg[a1] % i
      advance(6)
    when 0x15 # add
      reg[a0] = (reg[a1] + reg[a2]) % 2**32
      advance(4)
    when 0x16 # addi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] + i) % 2**32
      advance(7)
    when 0x17 # sub
    when 0x18 # subi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (2**32 + reg[a1] - i) % 2**32
      advance(7)
    when 0x19 # mul
    when 0x1a # muli
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] * i) % 2**32
      advance(7)
    when 0x1b # div
    when 0x1c # divi
    when 0x1d # xor
    when 0x1e # xori
    when 0x1f # or
    when 0x20 # ori
    when 0x21 # and
    when 0x22 # andi
    when 0x23 # shl
    when 0x24 # shli
    when 0x25 # shr
    when 0x26 # shri
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] >> i)
      advance(7)
    when 0x27 # li
      reg[a0] = reconstruct_int(a1, a2, a3, a4)
      advance(6)
    when 0x28 # lw
      reg[a0] = reg[a1]
      advance(3)
    when 0x29 # lh
      reg[a0] = reg[a1] & 0x0000ffff
      advance(3)
    when 0x2a # lb
      reg[a0] = reg[a1] & 0x000000ff
      advance(3)
    when 0x2b # sw
      # TODO: fixme
      raw = reg[a1]
      mem[reg[a0] + 0] = ((raw & 0xff000000) >> 24)
      mem[reg[a0] + 1] = ((raw & 0x00ff0000) >> 16)
      mem[reg[a0] + 2] = ((raw & 0x0000ff00) >> 8)
      mem[reg[a0] + 3] = ((raw & 0x000000ff))
      advance(3)
    when 0x2c # sh
      # TODO: fixme
      raw = reg[a1]
      mem[reg[a0] + 0] = ((raw & 0x0000ff00) >> 8)
      mem[reg[a0] + 1] = ((raw & 0x000000ff))
      advance(3)
    when 0x2d # sb
      address = reg[a1 & ~0x80]
      raw = mem[address]
      mem[reg[a0] + 0] = ((raw & 0x000000ff))
      advance(3)
    when 0xff # halt
      raise HaltException
    else
      raise "Unknown opcode: #{@opcode.inspect}"
    end
  end

  def at_pc(offset=0)
    mem[reg[PC] + offset]
  end

  def advance(amount)
    reg[PC] += amount
  end

  def reconstruct_int(x, y, z, t)
    (x << 24) + (y << 16) + (z << 8) + t
  end
end

context = Context.new

# Read instructions into memory
bytes = File.read(ARGV[0]).unpack('C*')
bytes.each_with_index do |byte, index|
  context.mem[index] = byte
end

# Set video memory
160.times do |x|
  120.times do |y|
    context.mem[0x10000 + (x * 120 + y)] = 0
  end
end

require 'sdl'

class Video
  def initialize(mem)
    @mem = mem
  end

  def init
    SDL.init(SDL::INIT_VIDEO)
    @screen = SDL::Screen.open(640, 480, 16, SDL::SWSURFACE)
    SDL::WM::set_caption('RCPU', 'RCPU')

    @black = @screen.format.map_rgb(0, 0, 0)
    @white = @screen.format.map_rgb(255, 255, 255)
  end

  def draw_memory
    row_length_in_bytes = 160
    num_rows = 120

    num_bytes = num_rows * row_length_in_bytes

    num_bytes.times do |index|
      x = (index % row_length_in_bytes)
      y = (index / row_length_in_bytes)

      byte = @mem.fetch(0x10000 + index)
      color = (byte != 0x00) ? @white : @black
      @screen.fill_rect(x * 4, y * 4, 4, 4, color)
    end

    @screen.flip
  end
end

# Run
Thread.abort_on_exception = true
Thread.new { CPU.new(context).run }

video = Video.new(context.mem)
video.init
loop { video.draw_memory }
