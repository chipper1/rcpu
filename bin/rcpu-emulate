#!/usr/bin/env ruby
# encoding: utf-8

class Context
  attr_reader :reg
  attr_accessor :mem

  def initialize
    @reg = {
      0 => 0, # r0
      1 => 0, # r1
      2 => 0, # r2
      3 => 0, # r3
      4 => 0, # r4
      5 => 0, # r5
      6 => 0, # r6
      7 => 0, # r7
      8 => 0, # pc
    }
    @mem = []
  end

  def inspect
    reg = ''
    reg << '┌─────┬───────────┬───────────┐' << "\n"
    reg << '│ loc │ val (hex) │ val (dec) │' << "\n"
    reg << '├─────┼───────────┼───────────┤' << "\n"
    @reg.each do |loc, val|
      reg << '│ '
      reg << format('%3i', loc)
      reg << ' │ '
      reg << '     0x' << format('%02x', val)
      reg << ' │ '
      reg << '      ' << format('%3i', val)
      reg << ' │' << "\n"
    end
    reg << '└─────┴───────────┴───────────┘' << "\n"
    reg
  end
end

class CPU
  class HaltException < StandardError
  end

  def initialize(context)
    @context = context
  end

  def run
    loop do
      begin
        step
      rescue HaltException
        break
      end
    end
  end

  private

  def mem
    @context.mem
  end

  def reg
    @context.reg
  end

  PC = 8
  FLAGS = 9

  def step
    opcode = at_pc
    a0 = at_pc(1)
    a1 = at_pc(2)
    a2 = at_pc(3)
    a3 = at_pc(4)
    a4 = at_pc(5)
    a5 = at_pc(6)

    case opcode
    when 0x00 # nop
      advance(1)
    when 0x01 # pushf
    when 0x02 # call
    when 0x03 # ret
    when 0x04 # push
    when 0x05 # pop
    when 0x06 # jmp
      reg[PC] = a0
    when 0x07 # je
      if reg[FLAGS] & 0x03 == 0x01 then reg[PC] = a0 else advance(2) end
    when 0x08 # jne
    when 0x09 # jg
      if reg[FLAGS] & 0x03 == 0x02 then reg[PC] = a0 else advance(2) end
    when 0x0a # jge
    when 0x0b # jl
      if reg[FLAGS] & 0x03 == 0x00 then reg[PC] = a0 else advance(2) end
    when 0x0c # jle
    when 0x0d # not
    when 0x0e # prn
      puts "#{reg[a0]}"
      advance(2)
    when 0x0f # mov
      reg[a0] = reg[a1]
      advance(3)
    when 0x10 # movi
      reg[a0] = reconstruct_int(a1, a2, a3, a4)
      advance(6)
    when 0x11 # cmp
      reg[FLAGS] =
        (reg[a0] == reg[a1] ? 0x01 : 0x00) |
        (reg[a0] > reg[a1]  ? 0x02 : 0x00)
      advance(3)
    when 0x12 # cmpi
      i = reconstruct_int(a1, a2, a3, a4)
      reg[FLAGS] =
        (reg[a0] == i ? 0x01 : 0x00) |
        (reg[a0] > i  ? 0x02 : 0x00)
      advance(6)
    when 0x13 # mod
      reg[a0] = reg[a1] % reg[a2]
      advance(4)
    when 0x14 # modi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = reg[a1] % i
      advance(4)
    when 0x15 # add
      reg[a0] = (reg[a1] + reg[a2]) % 2**32
      advance(4)
    when 0x16 # addi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] + i) % 2**32
      advance(4)
    when 0x17 # sub
    when 0x18 # subi
    when 0x19 # mul
    when 0x1a # muli
    when 0x1b # div
    when 0x1c # divi
    when 0x1d # xor
    when 0x1e # xori
    when 0x1f # or
    when 0x20 # ori
    when 0x21 # and
    when 0x22 # andi
    when 0x23 # shl
    when 0x24 # shli
    when 0x25 # shr
    when 0x26 # shri
    when 0xff # halt
      raise HaltException
    else
      raise "Unknown opcode: #{@opcode.inspect}"
    end
  end

  def at_pc(offset=0)
    mem[reg[PC] + offset]
  end

  def advance(amount)
    reg[PC] += amount
  end

  def reconstruct_int(x, y, z, t)
    (x << 24) + (y << 16) + (z << 8) + t
  end
end

# Run
context = Context.new
context.mem = File.read(ARGV[0]).unpack('C*')
CPU.new(context).run
