#!/usr/bin/env ruby
# encoding: utf-8

class Registers
  def initialize(mem)
    @mem = mem
    @reg = {
      0  => 0,      # r0
      1  => 0,      # r1
      2  => 0,      # r2
      3  => 0,      # r3
      4  => 0,      # r4
      5  => 0,      # r5
      6  => 0,      # r6
      7  => 0,      # r7
      8  => 0,      # rpc
      9  => 0,      # rflags
      10 => 0xffff, # rsp
      11 => 0,      # rbp
      12 => 0,      # rr
    }
  end

  def [](num)
    if num & 0x80 != 0x00
      address = self[num & ~0x80]
      (@mem.fetch(address + 3) << 24) +
      (@mem.fetch(address + 2) << 16) +
      (@mem.fetch(address + 1) << 8) +
      (@mem.fetch(address + 0) << 0)
    else
      @reg.fetch(num)
    end
  end

  def []=(num, value)
    if num & 0x80 != 0x00
      raise 'not supported'
    else
      @reg[num] = value
    end
  end

  def each
    @reg.each { |r| yield(r) }
  end
end

class Context
  attr_reader :reg
  attr_accessor :mem

  def initialize
    @mem = {}
    @reg = Registers.new(@mem)
  end

  def inspect
    stride = 10
    mem = ''
    i = 0
    prev_key = nil
    @mem.keys.sort.each do |key|
      # Split
      if prev_key && prev_key + 1 != key
        mem << "\n" << '----' << "\n"
        i = 0
      end
      prev_key = key

      mem << format('%04x=%02x ', key, @mem[key])

      mem << "\n" if i % stride == stride - 1
      i += 1
    end

    reg = ''
    reg << '┌─────┬───────────┬────────────┐' << "\n"
    reg << '│ loc │ val (hex) │ val (dec)  │' << "\n"
    reg << '├─────┼───────────┼────────────┤' << "\n"
    @reg.each do |loc, val|
      reg << '│ '
      reg << format('%3i', loc)
      reg << ' │ '
      reg << format(' %8x', val)
      reg << ' │ '
      reg << format('%10i', val)
      reg << ' │' << "\n"
    end
    reg << '└─────┴───────────┴────────────┘' << "\n"
    reg

    mem + "\n" + reg
  end
end

class CPU
  class HaltException < StandardError
  end

  def initialize(context)
    @context = context
  end

  def run
    loop do
      begin
        step
      rescue HaltException
        break
      end
    end
  end

  private

  def mem
    @context.mem
  end

  def reg
    @context.reg
  end

  PC = 8
  FLAGS = 9
  SP = 10
  BP = 11

  def step
    opcode = at_pc
    a0 = at_pc(1)
    a1 = at_pc(2)
    a2 = at_pc(3)
    a3 = at_pc(4)
    a4 = at_pc(5)
    a5 = at_pc(6)

    # puts @context.inspect
    # puts "*** 0x#{opcode.to_s(16)}"

    case opcode
    when 0x00 # nop
      advance(1)
    when 0x01 # call
      reg[SP] -= 4
      new_pc = reg[PC] + 5
      mem[reg[SP] + 3] = (new_pc & 0xff000000) >> 24
      mem[reg[SP] + 2] = (new_pc & 0x00ff0000) >> 16
      mem[reg[SP] + 1] = (new_pc & 0x0000ff00) >> 8
      mem[reg[SP] + 0] = (new_pc & 0x000000ff)
      i = reconstruct_int(a0, a1, a2, a3)
      reg[PC] = i
    when 0x02 # ret
      i = reconstruct_int(
        mem.fetch(reg[SP] + 3),
        mem.fetch(reg[SP] + 2),
        mem.fetch(reg[SP] + 1),
        mem.fetch(reg[SP] + 0)
      )
      reg[SP] += 4
      reg[PC] = i
    when 0x03 # push
      raw = reg[a0]
      reg[SP] -= 4
      mem[reg[SP] + 3] = (raw & 0xff000000) >> 24
      mem[reg[SP] + 2] = (raw & 0x00ff0000) >> 16
      mem[reg[SP] + 1] = (raw & 0x0000ff00) >> 8
      mem[reg[SP] + 0] = (raw & 0x000000ff)
      advance(2)
    when 0x04 # pushi
      reg[SP] -= 4
      mem[reg[SP] + 3] = a0
      mem[reg[SP] + 2] = a1
      mem[reg[SP] + 1] = a2
      mem[reg[SP] + 0] = a3
      advance(5)
    when 0x05 # pop
      reg[a0] = reconstruct_int(
        mem.fetch(reg[SP] + 3),
        mem.fetch(reg[SP] + 2),
        mem.fetch(reg[SP] + 1),
        mem.fetch(reg[SP] + 0)
      )
      reg[SP] += 4
      advance(2)
    when 0x06 # jmpi
      i = reconstruct_int(a0, a1, a2, a3)
      reg[PC] = i
    when 0xa6 # jmp
      reg[PC] = reg[a0]
    when 0x07 # je
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x01 == 0x01 then reg[PC] = i else advance(5) end
    when 0x08 # jne
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x01 == 0x00 then reg[PC] = i else advance(5) end
    when 0x09 # jg
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x02 == 0x02 then reg[PC] = i else advance(5) end
    when 0x0a # jge
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x03 != 0x00 then reg[PC] = i else advance(5) end
    when 0x0b # jl
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x03 == 0x00 then reg[PC] = i else advance(5) end
    when 0x0c # jle
      i = reconstruct_int(a0, a1, a2, a3)
      if reg[FLAGS] & 0x02 == 0x00 then reg[PC] = i else advance(5) end
    when 0x0d # not
    when 0x0e # prn
      puts "#{reg[a0]}"
      advance(2)
    when 0x0f # mov
      reg[a0] = reg[a1]
      advance(3)
    when 0x10 # movi
      reg[a0] = reconstruct_int(a1, a2, a3, a4)
      advance(6)
    when 0x11 # cmp
      reg[FLAGS] =
        (reg[a0] == reg[a1] ? 0x01 : 0x00) |
        (reg[a0] > reg[a1]  ? 0x02 : 0x00)
      advance(3)
    when 0x12 # cmpi
      i = reconstruct_int(a1, a2, a3, a4)
      reg[FLAGS] =
        (reg[a0] == i ? 0x01 : 0x00) |
        (reg[a0] > i  ? 0x02 : 0x00)
      advance(6)
    when 0x13 # mod
      reg[a0] = reg[a1] % reg[a2]
      advance(4)
    when 0x14 # modi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = reg[a1] % i
      advance(6)
    when 0x15 # add
      reg[a0] = (reg[a1] + reg[a2]) % 2**32
      advance(4)
    when 0x16 # addi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] + i) % 2**32
      advance(7)
    when 0x17 # sub
    when 0x18 # subi
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (2**32 + reg[a1] - i) % 2**32
      advance(7)
    when 0x19 # mul
    when 0x1a # muli
      i = reconstruct_int(a2, a3, a4, a5)
      reg[a0] = (reg[a1] * i) % 2**32
      advance(7)
    when 0x1b # div
    when 0x1c # divi
    when 0x1d # xor
    when 0x1e # xori
    when 0x1f # or
    when 0x20 # ori
    when 0x21 # and
    when 0x22 # andi
    when 0x23 # shl
    when 0x24 # shli
    when 0x25 # shr
    when 0x26 # shri
    when 0xff # halt
      raise HaltException
    else
      raise "Unknown opcode: #{@opcode.inspect}"
    end
  end

  def at_pc(offset=0)
    mem[reg[PC] + offset]
  end

  def advance(amount)
    reg[PC] += amount
  end

  def reconstruct_int(x, y, z, t)
    (x << 24) + (y << 16) + (z << 8) + t
  end
end

# Run
context = Context.new
bytes = File.read(ARGV[0]).unpack('C*')
bytes.each_with_index do |byte, index|
  context.mem[index] = byte
end
CPU.new(context).run
