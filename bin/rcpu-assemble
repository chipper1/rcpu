#!/usr/bin/env ruby
# encoding: utf-8

class RegArg
  MAPPING = {
    'r0'     => 0,
    'r1'     => 1,
    'r2'     => 2,
    'r3'     => 3,
    'r4'     => 4,
    'r5'     => 5,
    'r6'     => 6,
    'r7'     => 7,
    'rpc'    => 8,
    'rflags' => 9,
    'rsp'    => 10,
    'rbp'    => 11,
    'rr'     => 12,
  }

  attr_reader :name
  attr_reader :deref

  def initialize(name, deref)
    @name = name
    @deref = deref
  end

  def inspect
    "reg(#{@name}, #{@deref})"
  end

  def valid?
    MAPPING.key?(name)
  end

  def bytes(_labels)
    raw = MAPPING[name]
    if deref
      [raw | 0x80]
    else
      [raw]
    end
  end
end

class ImmArg
  attr_reader :value

  def initialize(value)
    @value = value
  end

  def inspect
    "imm(#{@value})"
  end

  def valid?
    true
  end

  def bytes(_labels)
    [
      (value & 0xff000000) >> 24,
      (value & 0x00ff0000) >> 16,
      (value & 0x0000ff00) >> 8,
      (value & 0x000000ff),
    ]
  end
end

# Inherits from ImmArg because this is a sort of unresolved immediate arg
class LabelArg < ImmArg
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "label(#{@name})"
  end

  def valid?
    true
  end

  def bytes(labels)
    if labels
      value = labels[name]
      [
        (value & 0xff000000) >> 24,
        (value & 0x00ff0000) >> 16,
        (value & 0x0000ff00) >> 8,
        (value & 0x000000ff),
      ]
    else
      [0x00, 0x00, 0x00, 0x00]
    end
  end
end

class Instruction
  attr_reader :opcode_mnemonic
  attr_reader :args

  def initialize(opcode_mnemonic, args)
    @opcode_mnemonic = opcode_mnemonic
    @args = args
  end

  def inspect
    "instr(#{@opcode_mnemonic}, args = #{@args.inspect})"
  end

  def instruction?
    true
  end

  def label?
    false
  end

  def data?
    false
  end
end

class Label
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "label(#{name.inspect})"
  end

  def instruction?
    false
  end

  def label?
    true
  end

  def data?
    false
  end
end

class Datax # Because Data is taken
  attr_reader :length
  attr_reader :number

  def initialize(length, number)
    @length = length
    @number = number
  end

  def inspect
    "data(#{name.inspect})"
  end

  def instruction?
    false
  end

  def label?
    false
  end

  def data?
    true
  end

  def serialize
    res = []
    (0..length-1).reverse_each do |i|
      shift = i << 3
      mask = 0xff << shift
      res << ((number & mask) >> shift)
    end
    res
  end
end

class Parser
  def parse_raw_lines(raw_lines)
    raw_lines.map { |rl| parse_raw_line(rl) }.compact
  end

  def parse_raw_line(raw_line)
    raw_line = raw_line.sub(/#.*/, '')

    if raw_line.strip.empty?
      nil
    elsif raw_line =~ /\A\s+/
      parts = raw_line.strip.split(/ +/)

      opcode_mnemonic = parts[0]
      args = parts[1..-1].map { |s| parse_arg(s.sub(/,\z/, '')) }

      Instruction.new(opcode_mnemonic, args)
    elsif raw_line =~ /\A\.([a-z]+) (.*)/
      parse_special($1, $2)
    else
      Label.new(raw_line.strip.sub(/:\z/, ''))
    end
  end

  def parse_special(raw_type, raw_value)
    number = parse_number(raw_value)

    length =
      case raw_type
      when 'byte'
        1
      when 'half'
        2
      when 'word'
        4
      else
        raise "Unrecognised special: #{raw_type}"
      end

    Datax.new(length, number)
  end

  def parse_number(string)
    case string
    when /\A0x[0-9a-fA-F]+\z/
      string[2..-1].to_i(16)
    when /\A0b[0-1]+\z/
      string[2..-1].to_i(2)
    when /\A\d+\z/
      string.to_i
    else
      nil
    end
  end

  def parse_arg(string)
    # Try as number
    number = parse_number(string)
    if number
      return ImmArg.new(number)
    end

    case string
    when /\A@[a-z0-9-]+\z/
      LabelArg.new(string[1..-1])
    when /\Ar[a-z0-9]+\z/
      RegArg.new(string, false)
    when /\A\[(r[a-z0-9]+)\]\z/
      RegArg.new($1, true)
    else
      raise "Cannot parse argument: #{string.inspect}"
    end
  end
end

class Assembler
  def initialize(raw_lines)
    @raw_lines = raw_lines
  end

  def assemble
    parser = Parser.new
    lines = parser.parse_raw_lines(@raw_lines)
    labels = collect_labels(lines)
    program = generate_program(lines, labels)
    program.pack('C*')
  end

  private

  def collect_labels(lines)
    labels = {}
    program = []
    lines.each do |line|
      if line.instruction?
        handle_instruction(line, program, nil)
      elsif line.label?
        labels[line.name] = program.size
      elsif line.data?
        line.length.times { program << 0x00 }
      end
    end
    labels
  end

  def generate_program(lines, labels)
    program = []
    lines.each do |line|
      if line.instruction?
        handle_instruction(line, program, labels)
      elsif line.data?
        line.serialize.each { |byte| program << byte }
      end
    end
    program
  end

  INSTRUCTION_DEFS = {
    'nop'   => { opcode: 0x00, args: [] },
    'call'  => { opcode: 0x01, args: [LabelArg] },
    'ret'   => { opcode: 0x02, args: [] },
    'push'  => { opcode: 0x03, args: [RegArg] },
    'pushi' => { opcode: 0x04, args: [ImmArg] },
    'pop'   => { opcode: 0x05, args: [RegArg] },
    'jmpi'  => { opcode: 0x06, args: [LabelArg] }, # FIXME: rearrange opcodes
    'jmp'   => { opcode: 0xa6, args: [RegArg] },
    'je'    => { opcode: 0x07, args: [LabelArg] },
    'jne'   => { opcode: 0x08, args: [LabelArg] },
    'jg'    => { opcode: 0x09, args: [LabelArg] },
    'jge'   => { opcode: 0x0a, args: [LabelArg] },
    'jl'    => { opcode: 0x0b, args: [LabelArg] },
    'jle'   => { opcode: 0x0c, args: [LabelArg] },
    'not'   => { opcode: 0x0d, args: [RegArg, RegArg] },
    'prn'   => { opcode: 0x0e, args: [RegArg] },
    'mov'   => { opcode: 0x0f, args: [RegArg, RegArg] },
    'movi'  => { opcode: 0x10, args: [RegArg, ImmArg] },
    'cmp'   => { opcode: 0x11, args: [RegArg, RegArg] },
    'cmpi'  => { opcode: 0x12, args: [RegArg, ImmArg] },
    'mod'   => { opcode: 0x13, args: [RegArg, RegArg, RegArg] },
    'modi'  => { opcode: 0x14, args: [RegArg, RegArg, ImmArg] },
    'add'   => { opcode: 0x15, args: [RegArg, RegArg, RegArg] },
    'addi'  => { opcode: 0x16, args: [RegArg, RegArg, ImmArg] },
    'sub'   => { opcode: 0x17, args: [RegArg, RegArg, RegArg] },
    'subi'  => { opcode: 0x18, args: [RegArg, RegArg, ImmArg] },
    'mul'   => { opcode: 0x19, args: [RegArg, RegArg, RegArg] },
    'muli'  => { opcode: 0x1a, args: [RegArg, RegArg, ImmArg] },
    'div'   => { opcode: 0x1b, args: [RegArg, RegArg, RegArg] },
    'divi'  => { opcode: 0x1c, args: [RegArg, RegArg, ImmArg] },
    'xor'   => { opcode: 0x1d, args: [RegArg, RegArg, RegArg] },
    'xori'  => { opcode: 0x1e, args: [RegArg, RegArg, ImmArg] },
    'or'    => { opcode: 0x1f, args: [RegArg, RegArg, RegArg] },
    'ori'   => { opcode: 0x20, args: [RegArg, RegArg, ImmArg] },
    'and'   => { opcode: 0x21, args: [RegArg, RegArg, RegArg] },
    'andi'  => { opcode: 0x22, args: [RegArg, RegArg, ImmArg] },
    'shl'   => { opcode: 0x23, args: [RegArg, RegArg, RegArg] },
    'shli'  => { opcode: 0x24, args: [RegArg, RegArg, ImmArg] },
    'shr'   => { opcode: 0x25, args: [RegArg, RegArg, RegArg] },
    'shri'  => { opcode: 0x26, args: [RegArg, RegArg, ImmArg] },
    'li'    => { opcode: 0x27, args: [RegArg, ImmArg] },
    'lw'    => { opcode: 0x28, args: [RegArg, RegArg] },
    'lh'    => { opcode: 0x29, args: [RegArg, RegArg] },
    'lb'    => { opcode: 0x2a, args: [RegArg, RegArg] },
    'sw'    => { opcode: 0x2b, args: [RegArg, RegArg] },
    'sh'    => { opcode: 0x2c, args: [RegArg, RegArg] },
    'sb'    => { opcode: 0x2d, args: [RegArg, RegArg] },
    'halt'  => { opcode: 0xff, args: [] },
  }

  # TODO: .byte
  # TODO: .word
  # TODO: .half
  # TODO: .align
  # TODO: .ascii / .asciiz

  # TODO: remove mov
  # TODO: replace [] syntax with imm(reg) syntax
  # TODO: use ; for comments

  def handle_instruction(instr, program, labels)
    instr_def = INSTRUCTION_DEFS.fetch(instr.opcode_mnemonic) do
      raise "Unknown instruction name: #{instr.opcode_mnemonic}"
    end

    # Add opcode
    opcode = instr_def.fetch(:opcode)
    program << opcode

    # Validate args
    if instr.args.size != instr_def.fetch(:args).size
      raise "Incorrect argument count (#{instr.inspect}; is #{instr.args.size}, expected #{instr_def.fetch(:args).size}"
    end
    instr.args.each_with_index do |arg, i|
      arg_def = [instr_def.fetch(:args).fetch(i)].flatten
      unless arg_def.any? { |d| arg.is_a?(d) }
        raise "Incorrect argument type (#{instr.inspect}; is #{arg.class}, expected #{arg_def})"
      end
      unless arg.valid?
        raise "Invalid argument (#{instr.inspect}; #{arg.inspect})"
      end
    end

    # Add args
    instr.args.each do |arg|
      arg.bytes(labels).each { |b| program << b }
    end
  end
end

# Get filenames
if ARGV.size != 1
  $stderr.puts 'usage: rcpu-assemble [filename]'
  exit 1
end
input_filename = ARGV[0]
output_filename =
  File.join(
    File.dirname(input_filename),
    File.basename(input_filename, '.rcs') + '.rcb')

# Read
raw_lines = File.readlines(input_filename)

# Assemble
data = Assembler.new(raw_lines).assemble

# Write
File.open(output_filename, 'w') { |io| io << data }
