#!/usr/bin/env ruby
# encoding: utf-8

def resolve_reg(s)
  case s
  when 'r0'
    0
  when 'r1'
    1
  when 'r2'
    2
  when 'r3'
    3
  when 'r4'
    4
  when 'r5'
    5
  when 'r6'
    6
  when 'r7'
    7
  when 'rpc'
    8
  when 'rflags'
    9
  else
    raise "Unknown register: #{s}"
  end
end

def parse_imm(s)
  raw =
    case s
    when /\A0x/
      s.to_i(16)
    else
      s.to_i(10)
    end

  [
    (raw & 0xff000000) >> 24,
    (raw & 0x00ff0000) >> 16,
    (raw & 0x0000ff00) >> 8,
    (raw & 0x000000ff),
  ]
end

def label?(s)
  s =~ /\A@/
end

def parse_label(s, labels)
  res = labels[s[1..-1]]
  if res.nil?
    raise "Unknown label: #{s}"
  else
    res
  end
end

def handle_instruction(instr, program, labels)
  case instr[0]
  when 'nop'
    program << 0x00
  when 'pushf'
    # not implemented
  when 'call'
    # not implemented
  when 'ret'
    # not implemented
  when 'push'
    # not implemented
  when 'pop'
    # not implemented
  when 'jmp'
    program << 0x06
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'je'
    program << 0x07
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'jne'
    program << 0x08
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'jg'
    program << 0x09
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'jge'
    program << 0x0a
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'jl'
    program << 0x0b
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'jle'
    program << 0x0c
    program << (labels ? parse_label(instr[1], labels) : 0x00)
  when 'not'
    program << 0x0d
    program << resolve_reg(instr[1])
  when 'prn'
    program << 0x0e
    program << resolve_reg(instr[1])
  when 'mov'
    program << 0x0f
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
  when 'movi'
    program << 0x10
    program << resolve_reg(instr[1])
    parse_imm(instr[2]).each { |byte| program << byte }
  when 'cmp'
    program << 0x11
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
  when 'cmpi'
    program << 0x12
    program << resolve_reg(instr[1])
    parse_imm(instr[2]).each { |byte| program << byte }
  when 'mod'
    program << 0x13
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
    program << resolve_reg(instr[3])
  when 'modi'
    program << 0x14
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
    parse_imm(instr[3]).each { |byte| program << byte }
  when 'add'
    program << 0x15
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
    program << resolve_reg(instr[3])
  when 'addi'
    program << 0x16
    program << resolve_reg(instr[1])
    program << resolve_reg(instr[2])
    parse_imm(instr[3]).each { |byte| program << byte }
  when 'sub'
    # not implemented
  when 'subi'
    # not implemented
  when 'mul'
    # not implemented
  when 'muli'
    # not implemented
  when 'div'
    # not implemented
  when 'divi'
    # not implemented
  when 'xor'
    # not implemented
  when 'xori'
    # not implemented
  when 'or'
    # not implemented
  when 'ori'
    # not implemented
  when 'and'
    # not implemented
  when 'andi'
    # not implemented
  when 'shl'
    # not implemented
  when 'shli'
    # not implemented
  when 'shr'
    # not implemented
  when 'shri'
    # not implemented
  when 'halt'
    program << 0xff
  else
    raise "Unknown instruction name: #{instr[0]}"
  end
end

lines = File.readlines(ARGV[0])

labels = {}

# First pass: collect labels
program = []
lines.each do |line|
  if line =~ /\A\s+/
    # Instruction
    instr = line.strip.split(/ +/)
    handle_instruction(instr, program, nil)
  else
    # Label
    label = line.strip
    labels[label] = program.size
  end
end

# Second pass: write instructions
program = []
lines.each do |line|
  if line =~ /\A\s+/
    # Instruction
    instr = line.strip.split(/ +/)
    handle_instruction(instr, program, labels)
  end
end

print program.pack('C*')
