#!/usr/bin/env ruby
# encoding: utf-8

def resolve_reg(s)
  case s
  when 'r0'
    0
  when 'r1'
    1
  when 'r2'
    2
  when 'r3'
    3
  when 'r4'
    4
  when 'r5'
    5
  when 'r6'
    6
  when 'r7'
    7
  when 'rpc'
    8
  when 'rflags'
    9
  when 'rsp'
    10
  when 'rbp'
    11
  else
    raise "Unknown register: #{s}"
  end
end

def parse_imm(s)
  raw =
    case s
    when /\A0x/
      s.to_i(16)
    else
      s.to_i(10)
    end

  [
    (raw & 0xff000000) >> 24,
    (raw & 0x00ff0000) >> 16,
    (raw & 0x0000ff00) >> 8,
    (raw & 0x000000ff),
  ]
end

def label?(s)
  s =~ /\A@/
end

def parse_label(s, labels)
  res = labels[s[1..-1]]
  if res.nil?
    raise "Unknown label: #{s}"
  else
    res
  end
end

def handle_instruction(instr, program, labels)
  $stderr.puts "Assembling #{instr}"

  case instr.opcode_mnemonic
  when 'nop'
    program << 0x00
  when 'call'
    # not implemented
  when 'ret'
    # not implemented
  when 'push'
    program << 0x03
    program << resolve_reg(instr.args[0])
  when 'pushi'
    program << 0x04
    parse_imm(instr.args[0]).each { |byte| program << byte }
  when 'pop'
    program << 0x05
    program << resolve_reg(instr.args[0])
  when 'jmp'
    program << 0x06
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'je'
    program << 0x07
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'jne'
    program << 0x08
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'jg'
    program << 0x09
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'jge'
    program << 0x0a
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'jl'
    program << 0x0b
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'jle'
    program << 0x0c
    program << (labels ? parse_label(instr.args[0], labels) : 0x00)
  when 'not'
    program << 0x0d
    program << resolve_reg(instr.args[0])
  when 'prn'
    program << 0x0e
    program << resolve_reg(instr.args[0])
  when 'mov'
    program << 0x0f
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
  when 'movi'
    program << 0x10
    program << resolve_reg(instr.args[0])
    parse_imm(instr.args[1]).each { |byte| program << byte }
  when 'cmp'
    program << 0x11
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
  when 'cmpi'
    program << 0x12
    program << resolve_reg(instr.args[0])
    parse_imm(instr.args[1]).each { |byte| program << byte }
  when 'mod'
    program << 0x13
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
    program << resolve_reg(instr.args[2])
  when 'modi'
    program << 0x14
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
    parse_imm(instr.args[2]).each { |byte| program << byte }
  when 'add'
    program << 0x15
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
    program << resolve_reg(instr.args[2])
  when 'addi'
    program << 0x16
    program << resolve_reg(instr.args[0])
    program << resolve_reg(instr.args[1])
    parse_imm(instr.args[2]).each { |byte| program << byte }
  when 'sub'
    # not implemented
  when 'subi'
    # not implemented
  when 'mul'
    # not implemented
  when 'muli'
    # not implemented
  when 'div'
    # not implemented
  when 'divi'
    # not implemented
  when 'xor'
    # not implemented
  when 'xori'
    # not implemented
  when 'or'
    # not implemented
  when 'ori'
    # not implemented
  when 'and'
    # not implemented
  when 'andi'
    # not implemented
  when 'shl'
    # not implemented
  when 'shli'
    # not implemented
  when 'shr'
    # not implemented
  when 'shri'
    # not implemented
  when 'halt'
    program << 0xff
  else
    raise "Unknown instruction name: #{instr.opcode_mnemonic}"
  end
end

def parse_line(string)
  if string =~ /\A\s+/
    Instruction.parse(string.strip)
  else
    Label.new(string.strip)
  end
end

class Instruction
  attr_reader :opcode_mnemonic
  attr_reader :args

  def self.parse(string)
    parts = string.split(/ +/)

    opcode_mnemonic = parts[0]
    args = parts[1..-1]

    new(opcode_mnemonic, args)
  end

  def initialize(opcode_mnemonic, args)
    @opcode_mnemonic = opcode_mnemonic
    @args = args
  end

  def to_s
    "instr(#{@opcode_mnemonic}, args = #{@args.inspect})"
  end

  def instruction?
    true
  end

  def label?
    false
  end

end

class Label
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def to_s
    "label(#{name.inspect})"
  end

  def instruction?
    false
  end

  def label?
    true
  end
end

if ARGV.size != 1
  $stderr.puts 'usage: rcpu-assemble [filename]'
  exit 1
end
input_filename = ARGV[0]
output_filename =
  File.join(
    File.dirname(input_filename),
    File.basename(input_filename, '.rcs') + '.rcb')

raw_lines = File.readlines(input_filename)

labels = {}

# First pass: collect labels
$stderr.puts "*** Pass 1: collecting labels"
program = []
lines = raw_lines.map { |s| parse_line(s) }
lines.each do |line|
  if line.instruction?
    handle_instruction(line, program, nil)
  else
    labels[line.name] = program.size
  end
end

# Second pass: write instructions
$stderr.puts "*** Pass 2: assembling"
program = []
lines.each do |line|
  if line.instruction?
    handle_instruction(line, program, labels)
  end
end

File.open(output_filename, 'w') { |io| io << program.pack('C*') }
