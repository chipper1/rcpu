#!/usr/bin/env ruby
# encoding: utf-8

def handle_instruction(instr, program, labels)
  $stderr.puts "Assembling #{instr}"

  case instr.opcode_mnemonic
  when 'nop'
    program << 0x00
  when 'call'
    # not implemented
  when 'ret'
    # not implemented
  when 'push'
    program << 0x03
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'pushi'
    program << 0x04
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'pop'
    program << 0x05
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jmp'
    program << 0x06
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'je'
    program << 0x07
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jne'
    program << 0x08
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jg'
    program << 0x09
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jge'
    program << 0x0a
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jl'
    program << 0x0b
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'jle'
    program << 0x0c
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'not'
    program << 0x0d
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'prn'
    program << 0x0e
    instr.args[0].bytes(labels).each { |b| program << b }
  when 'mov'
    program << 0x0f
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
  when 'movi'
    program << 0x10
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
  when 'cmp'
    program << 0x11
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
  when 'cmpi'
    program << 0x12
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
  when 'mod'
    program << 0x13
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
    instr.args[2].bytes(labels).each { |b| program << b }
  when 'modi'
    program << 0x14
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
    instr.args[2].bytes(labels).each { |b| program << b }
  when 'add'
    program << 0x15
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
    instr.args[2].bytes(labels).each { |b| program << b }
  when 'addi'
    program << 0x16
    instr.args[0].bytes(labels).each { |b| program << b }
    instr.args[1].bytes(labels).each { |b| program << b }
    instr.args[2].bytes(labels).each { |b| program << b }
  when 'sub'
    # not implemented
  when 'subi'
    # not implemented
  when 'mul'
    # not implemented
  when 'muli'
    # not implemented
  when 'div'
    # not implemented
  when 'divi'
    # not implemented
  when 'xor'
    # not implemented
  when 'xori'
    # not implemented
  when 'or'
    # not implemented
  when 'ori'
    # not implemented
  when 'and'
    # not implemented
  when 'andi'
    # not implemented
  when 'shl'
    # not implemented
  when 'shli'
    # not implemented
  when 'shr'
    # not implemented
  when 'shri'
    # not implemented
  when 'halt'
    program << 0xff
  else
    raise "Unknown instruction name: #{instr.opcode_mnemonic}"
  end
end

def parse_line(string)
  if string =~ /\A\s+/
    Instruction.parse(string.strip)
  else
    Label.new(string.strip)
  end
end

def parse_arg(string)
  case string
  when /\A@/
    LabelArg.new(string[1..-1])
  when /\Ar/
    RegisterArg.new(string)
  when /\A0x\d+/
    ImmediateArg.new(string[2..-1].to_i(16))
  when /\A\d+/
    ImmediateArg.new(string.to_i)
  else
    raise "Cannot parse argument: #{string.inspect}"
  end
end

class RegisterArg
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "reg(#{@name})"
  end

  def bytes(_labels)
    num =
      case name
      when 'r0'
        0
      when 'r1'
        1
      when 'r2'
        2
      when 'r3'
        3
      when 'r4'
        4
      when 'r5'
        5
      when 'r6'
        6
      when 'r7'
        7
      when 'rpc'
        8
      when 'rflags'
        9
      when 'rsp'
        10
      when 'rbp'
        11
      else
        raise "Unknown register: #{s}"
      end

    [num]
  end
end

class ImmediateArg
  attr_reader :value

  def initialize(value)
    @value = value
  end

  def inspect
    "imm(#{@value})"
  end

  def bytes(_labels)
    [
      (value & 0xff000000) >> 24,
      (value & 0x00ff0000) >> 16,
      (value & 0x0000ff00) >> 8,
      (value & 0x000000ff),
    ]
  end
end

class LabelArg
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "label(#{@name})"
  end

  def bytes(labels)
    # FIXME: Should labels not be 4 bytes?
    if labels
      [labels[name]]
    else
      [0x00]
    end
  end
end

class Instruction
  attr_reader :opcode_mnemonic
  attr_reader :args

  def self.parse(string)
    parts = string.split(/ +/)

    opcode_mnemonic = parts[0]
    args = parts[1..-1].map { |s| parse_arg(s) }

    new(opcode_mnemonic, args)
  end

  def initialize(opcode_mnemonic, args)
    @opcode_mnemonic = opcode_mnemonic
    @args = args
  end

  def to_s
    "instr(#{@opcode_mnemonic}, args = #{@args.inspect})"
  end

  def instruction?
    true
  end
end

class Label
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def to_s
    "label(#{name.inspect})"
  end

  def instruction?
    false
  end
end

if ARGV.size != 1
  $stderr.puts 'usage: rcpu-assemble [filename]'
  exit 1
end
input_filename = ARGV[0]
output_filename =
  File.join(
    File.dirname(input_filename),
    File.basename(input_filename, '.rcs') + '.rcb')

raw_lines = File.readlines(input_filename)

labels = {}

# First pass: collect labels
$stderr.puts "*** Pass 1: collecting labels"
program = []
lines = raw_lines.map { |s| parse_line(s) }
lines.each do |line|
  if line.instruction?
    handle_instruction(line, program, nil)
  else
    labels[line.name] = program.size
  end
end

# Second pass: write instructions
$stderr.puts "*** Pass 2: assembling"
program = []
lines.each do |line|
  if line.instruction?
    handle_instruction(line, program, labels)
  end
end

File.open(output_filename, 'w') { |io| io << program.pack('C*') }
