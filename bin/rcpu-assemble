#!/usr/bin/env ruby
# encoding: utf-8

class RegisterArg
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "reg(#{@name})"
  end

  def bytes(_labels)
    num =
      case name
      when 'r0'
        0
      when 'r1'
        1
      when 'r2'
        2
      when 'r3'
        3
      when 'r4'
        4
      when 'r5'
        5
      when 'r6'
        6
      when 'r7'
        7
      when 'rpc'
        8
      when 'rflags'
        9
      when 'rsp'
        10
      when 'rbp'
        11
      else
        raise "Unknown register: #{s}"
      end

    [num]
  end
end

class ImmediateArg
  attr_reader :value

  def initialize(value)
    @value = value
  end

  def inspect
    "imm(#{@value})"
  end

  def bytes(_labels)
    [
      (value & 0xff000000) >> 24,
      (value & 0x00ff0000) >> 16,
      (value & 0x0000ff00) >> 8,
      (value & 0x000000ff),
    ]
  end
end

class LabelArg
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def inspect
    "label(#{@name})"
  end

  def bytes(labels)
    # FIXME: Should labels not be 4 bytes?
    if labels
      [labels[name]]
    else
      [0x00]
    end
  end
end

class Instruction
  attr_reader :opcode_mnemonic
  attr_reader :args

  def initialize(opcode_mnemonic, args)
    @opcode_mnemonic = opcode_mnemonic
    @args = args
  end

  def to_s
    "instr(#{@opcode_mnemonic}, args = #{@args.inspect})"
  end

  def instruction?
    true
  end
end

class Label
  attr_reader :name

  def initialize(name)
    @name = name
  end

  def to_s
    "label(#{name.inspect})"
  end

  def instruction?
    false
  end
end

class Parser
  def parse_line(string)
    if string =~ /\A\s+/
      parts = string.strip.split(/ +/)

      opcode_mnemonic = parts[0]
      args = parts[1..-1].map { |s| parse_arg(s) }

      Instruction.new(opcode_mnemonic, args)
    else
      Label.new(string.strip)
    end
  end

  def parse_arg(string)
    case string
    when /\A@/
      LabelArg.new(string[1..-1])
    when /\Ar/
      RegisterArg.new(string)
    when /\A0x\d+/
      ImmediateArg.new(string[2..-1].to_i(16))
    when /\A\d+/
      ImmediateArg.new(string.to_i)
    else
      raise "Cannot parse argument: #{string.inspect}"
    end
  end
end

class Assembler
  def initialize(raw_lines)
    @raw_lines = raw_lines
  end

  def assemble
    parser = Parser.new
    lines = @raw_lines.map { |s| parser.parse_line(s) }
    labels = collect_labels(lines)
    program = generate_program(lines, labels)
    program.pack('C*')
  end

  private

  def collect_labels(lines)
    labels = {}
    program = []
    lines.each do |line|
      if line.instruction?
        handle_instruction(line, program, nil)
      else
        labels[line.name] = program.size
      end
    end
    labels
  end

  def generate_program(lines, labels)
    program = []
    lines.each do |line|
      if line.instruction?
        handle_instruction(line, program, labels)
      end
    end
    program
  end

  OPCODES = {
    'nop'   => 0x00,
    'call'  => 0x01,
    'ret'   => 0x02,
    'push'  => 0x03,
    'pushi' => 0x04,
    'pop'   => 0x05,
    'jmp'   => 0x06,
    'je'    => 0x07,
    'jne'   => 0x08,
    'jg'    => 0x09,
    'jge'   => 0x0a,
    'jl'    => 0x0b,
    'jle'   => 0x0c,
    'not'   => 0x0d,
    'prn'   => 0x0e,
    'mov'   => 0x0f,
    'movi'  => 0x10,
    'cmp'   => 0x11,
    'cmpi'  => 0x12,
    'mod'   => 0x13,
    'modi'  => 0x14,
    'add'   => 0x15,
    'addi'  => 0x16,
    'sub'   => 0x17,
    'subi'  => 0x18,
    'mul'   => 0x19,
    'muli'  => 0x1a,
    'div'   => 0x1b,
    'divi'  => 0x1c,
    'xor'   => 0x1d,
    'xori'  => 0x1e,
    'or'    => 0x1f,
    'ori'   => 0x20,
    'and'   => 0x21,
    'andi'  => 0x22,
    'shl'   => 0x23,
    'shli'  => 0x24,
    'shr'   => 0x25,
    'shri'  => 0x26,
    'halt'  => 0xff,
  }

  def handle_instruction(instr, program, labels)
    # Add opcode
    opcode = OPCODES.fetch(instr.opcode_mnemonic) do
      raise "Unknown instruction name: #{instr.opcode_mnemonic}"
    end
    program << opcode

    # Add args
    instr.args.each do |arg|
      arg.bytes(labels).each { |b| program << b }
    end
  end
end

# Get filenames
if ARGV.size != 1
  $stderr.puts 'usage: rcpu-assemble [filename]'
  exit 1
end
input_filename = ARGV[0]
output_filename =
  File.join(
    File.dirname(input_filename),
    File.basename(input_filename, '.rcs') + '.rcb')

# Read
raw_lines = File.readlines(input_filename)

# Assemble
data = Assembler.new(raw_lines).assemble

# Write
File.open(output_filename, 'w') { |io| io << data }
